# ApproximateComputations.jl

[![Build Status](https://travis-ci.org/NTimmons/ApproximateComputations.jl.svg?branch=master)](https://travis-ci.org/NTimmons/ApproximateComputations.jl)[![codecov](https://codecov.io/gh/NTimmons/ApproximateComputations.jl/branch/master/graph/badge.svg)](https://codecov.io/gh/NTimmons/ApproximateComputations.jl)

ApproximateComputations.jl is a library for the automatic applicaiton approximate computation software techniques to existing code. In this context, software approximation is where we perform some transformation to existing code to reduce the accuracy for gain in performance.

This is usually applied through function replacement. The standard workflow is to determine the maximum or average acceptable error for a given code block and then reducing the accuracy of the function so that as little work as possible is spent on gaining a more acurate result that the acceptable level.


### Tutorial
An example of the usage of the small set of functions currently in this library is avialable below.
In this small example we show how to generate a replacement for the function 'sin' that has an average error when compared to the high-precision implementation of no more than 1x10^-8.


1) Generate new functions which approximate 'sin' in the range 0.001 to pi/2 
```
using ApproximateComputations
newFunctionsAndInformation = GenerateAllApproximationFunctions(sin, 0.001, 1.57)
```

2) Filter the generated functions to select the fastest executing function within our error constraint:
```
a = GetFastestAcceptable(newFunctionsAndInformation, meanErrorLimit=0.00000001)
println(GetFunctionName(a))  # -> returns sin_PolyLet9_Float64bit
```

3) Store the function for use:
```
approxsin = a.generatedFunction
```

4) Compare to accurate function:
```
approxResult = approxsin(1.0) # -> Approximation{Float64}(0.8414709848311571)
realResult = sin(1.0)   # -> {Float64} (0.8414709848078965)
```

#### Using the Approximation type:
Approximated functions return a type wrapped in Approximation.
This is to prevent unintentional mixing of approximate space data with high precision data.

5) To convert from an approximation to the original type we use Get(x)

```
x = Get(approxResult) # -> {Float64} (0.8414709848311571)
```

#### Extra function information:
To be able to produce and select an appropriate approximation the package also contains graphing functions to show the behaviours of the different functions generated by 'GenerateAllApproximationFunctions' as well as filtering functions select only the functions which match constraints on error, runtime or internal type precision.

### AST Tutorial
We have implemented a simple AST for altering functions and breaking them into chunks for analysis. The use is relatively simple

```
using ApproximateComputations
using ImportAll
@importall Base
```

First we need to include this package and importall of Base. We need to import all the functions to allow us to override them. We need to override them so we can make them work with our wrapper types and in some cases, inject diagnostics.

We can define a normal function, in this case "little", and then submit the function to `UpdateEnvironmentForFunction`. This will identify all the functions that are called from this function and override them for our wrapper types.
```
little(x)  = (x * 2) + 5
UpdateEnvironmentForFunction(little)
```
We can then produce our AST from this object by passing in our inputs to the functions in the `Variable` type like this:
```
littletree = little(Variable(123))
printtree(littletree)

==> |+(id:3)
    |  |*(id:2)
    |  |  |123(id:1)
    |  |  |2
    |  |5
```
This shows our valid AST, and the ID for each operation.

This AST can be executed as a tree using the `EmulateTree` function
```
EmulateTree(littletree)
==> 251
```
or you can call the function directly:
```
little(123)
==> 251
```

If we want to modify the tree we can do so by supplying a replacement sub-tree and the id of the part of the tree that is to be replaced.

In this case we are changing the function from  `(123 * 2) + 5` to `(0 * 2) + 5`
```
ReplaceSubTree(littletree, Variable(0), 1)
printtree(littletree)
==> |+(id:3)
    |  |*(id:2)
    |  |  |0(id:4)
    |  |  |2
    |  |5
```
This changes the input tree and can then be ran to show that the result is now what we expect:

```
EmulateTree(littletree)
==> 5
```

Nice and simple, but allows for powerful automated transformations!
